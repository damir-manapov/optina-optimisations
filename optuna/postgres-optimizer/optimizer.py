#!/usr/bin/env python3
"""
Multi-Cloud Postgres Configuration Optimizer using Bayesian Optimization (Optuna).

Supports two optimization modes:
- infra: Tune VM specs (CPU, RAM, disk) - creates new VM per trial
- config: Tune postgresql.conf on fixed host - reconfigures existing VM

Usage:
    # Infrastructure optimization (tune VM specs)
    uv run python postgres-optimizer/optimizer.py --cloud timeweb --mode infra --trials 10

    # Config optimization on fixed host (faster, more trials)
    uv run python postgres-optimizer/optimizer.py --cloud timeweb --mode config --cpu 8 --ram 32 --trials 50

    # Full optimization (infra first, then config on best host)
    uv run python postgres-optimizer/optimizer.py --cloud timeweb --mode full --trials 20

    # Show results / export
    uv run python postgres-optimizer/optimizer.py --cloud timeweb --show-results
    uv run python postgres-optimizer/optimizer.py --cloud timeweb --export-md
"""

import argparse
import json
import re
import sys
import time
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from pathlib import Path

import optuna
from optuna.samplers import TPESampler

# Add parent dir to path for common imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from common import (
    destroy_all,
    get_terraform,
    get_tf_output,
    load_results,
    run_ssh_command,
    save_results,
    wait_for_vm_ready,
)

from cloud_config import (
    CloudConfig,
    get_cloud_config,
    get_config_search_space,
    get_infra_search_space,
)
from pricing import DiskConfig, calculate_vm_cost, filter_valid_ram

RESULTS_DIR = Path(__file__).parent
STUDY_DB = RESULTS_DIR / "study.db"


class Mode(Enum):
    """Optimization mode."""

    INFRA = "infra"  # Tune VM specs (CPU, RAM, disk)
    CONFIG = "config"  # Tune postgresql.conf (fixed host)
    FULL = "full"  # Both phases


# Available optimization metrics
METRICS = {
    "tps": "Transactions per second (higher is better)",
    "latency_avg_ms": "Average latency in ms (lower is better)",
    "cost_efficiency": "TPS per $/hr (higher is better)",
}


@dataclass
class TrialTimings:
    """Timing measurements for each phase of a trial."""

    terraform_s: float = 0.0  # Terraform apply
    vm_ready_s: float = 0.0  # Wait for VM cloud-init
    pg_ready_s: float = 0.0  # Wait for Postgres service
    pgbench_init_s: float = 0.0  # Initialize pgbench tables
    benchmark_s: float = 0.0  # pgbench run
    trial_total_s: float = 0.0  # End-to-end trial time


@dataclass
class BenchmarkResult:
    """pgbench benchmark results."""

    tps: float = 0.0
    latency_avg_ms: float = 0.0
    latency_stddev_ms: float = 0.0
    transactions: int = 0
    duration_s: float = 0.0
    error: str | None = None
    timings: TrialTimings | None = None
    pgbench_init_s: float = 0.0  # Initialize pgbench tables
    benchmark_s: float = 0.0  # pgbench run
    trial_total_s: float = 0.0  # End-to-end trial time


def results_file() -> Path:
    """Get results file path."""
    return RESULTS_DIR / "results.json"


def config_to_key(infra: dict, pg_config: dict, cloud: str) -> str:
    """Convert config dicts to a hashable key for deduplication."""
    return json.dumps({"cloud": cloud, "infra": infra, "pg": pg_config}, sort_keys=True)


def find_cached_result(infra: dict, pg_config: dict, cloud: str) -> dict | None:
    """Find a cached successful result for the given config."""
    target_key = config_to_key(infra, pg_config, cloud)
    for result in load_results(results_file()):
        result_key = config_to_key(
            result.get("infra_config", {}),
            result.get("pg_config", {}),
            result.get("cloud", ""),
        )
        if result_key == target_key:
            if result.get("error"):
                return None
            if result.get("tps", 0) <= 0:
                return None
            return result
    return None


def generate_postgresql_conf(pg_config: dict, ram_gb: int) -> str:
    """Generate postgresql.conf tuning content."""
    # Calculate memory values
    shared_buffers_mb = int(ram_gb * 1024 * pg_config["shared_buffers_pct"] / 100)
    effective_cache_size_mb = int(
        ram_gb * 1024 * pg_config["effective_cache_size_pct"] / 100
    )

    return f"""# Auto-generated by postgres-optimizer
# RAM: {ram_gb}GB

# Memory
shared_buffers = {shared_buffers_mb}MB
effective_cache_size = {effective_cache_size_mb}MB
work_mem = {pg_config["work_mem_mb"]}MB
maintenance_work_mem = {pg_config["maintenance_work_mem_mb"]}MB

# Connections
max_connections = {pg_config["max_connections"]}

# Planner
random_page_cost = {pg_config["random_page_cost"]}
effective_io_concurrency = {pg_config["effective_io_concurrency"]}

# WAL
wal_buffers = {pg_config["wal_buffers_mb"]}MB
max_wal_size = {pg_config["max_wal_size_gb"]}GB
checkpoint_completion_target = {pg_config["checkpoint_completion_target"]}

# Workers
max_worker_processes = {pg_config["max_worker_processes"]}
max_parallel_workers_per_gather = {pg_config["max_parallel_workers_per_gather"]}
max_parallel_workers = {pg_config["max_worker_processes"]}
"""


def reconfigure_postgres(
    vm_ip: str,
    pg_config: dict,
    ram_gb: int,
    mode: str = "single",
    jump_host: str | None = None,
) -> bool:
    """Reconfigure Postgres with new settings (no VM recreation).

    Args:
        vm_ip: Postgres VM IP (internal)
        pg_config: PostgreSQL configuration parameters
        ram_gb: RAM in GB for the VM
        mode: 'single' or 'cluster'
        jump_host: Benchmark VM IP to use as SSH jump host (for internal IPs)
    """
    print(f"  Reconfiguring Postgres ({mode} mode) with: {pg_config}")

    if mode == "cluster":
        return reconfigure_patroni(vm_ip, pg_config, ram_gb, jump_host)
    else:
        return reconfigure_postgres_single(vm_ip, pg_config, ram_gb, jump_host)


def reconfigure_postgres_single(
    vm_ip: str, pg_config: dict, ram_gb: int, jump_host: str | None = None
) -> bool:
    """Reconfigure single Postgres node via conf.d."""
    config_content = generate_postgresql_conf(pg_config, ram_gb)

    # Upload config (PostgreSQL 18)
    upload_cmd = f"cat > /etc/postgresql/18/main/conf.d/tuning.conf << 'EOF'\n{config_content}\nEOF"
    code, output = run_ssh_command(vm_ip, upload_cmd, timeout=30, jump_host=jump_host)
    if code != 0:
        print(f"  Failed to upload config: {output}")
        return False

    # Restart Postgres
    restart_cmd = "systemctl restart postgresql && sleep 3 && pg_isready"
    code, output = run_ssh_command(vm_ip, restart_cmd, timeout=60, jump_host=jump_host)
    if code != 0:
        print(f"  Failed to restart Postgres: {output}")
        return False

    print("  Postgres reconfigured successfully")
    return True


def reconfigure_patroni(
    vm_ip: str, pg_config: dict, ram_gb: int, jump_host: str | None = None
) -> bool:
    """Reconfigure Patroni cluster via patronictl."""
    # Generate config values
    shared_buffers = int(ram_gb * 1024 * pg_config["shared_buffers_pct"] / 100)
    effective_cache_size = int(
        ram_gb * 1024 * pg_config["effective_cache_size_pct"] / 100
    )

    # Build YAML patch for patronictl
    patch_yaml = f"""postgresql:
  parameters:
    shared_buffers: "{shared_buffers}MB"
    effective_cache_size: "{effective_cache_size}MB"
    work_mem: "{pg_config["work_mem_mb"]}MB"
    maintenance_work_mem: "{pg_config["maintenance_work_mem_mb"]}MB"
    max_connections: {pg_config["max_connections"]}
    random_page_cost: {pg_config["random_page_cost"]}
    effective_io_concurrency: {pg_config["effective_io_concurrency"]}
    wal_buffers: "{pg_config["wal_buffers_mb"]}MB"
    max_wal_size: "{pg_config["max_wal_size_gb"]}GB"
    checkpoint_completion_target: {pg_config["checkpoint_completion_target"]}
    max_worker_processes: {pg_config["max_worker_processes"]}
    max_parallel_workers_per_gather: {pg_config["max_parallel_workers_per_gather"]}
    max_parallel_workers: {pg_config["max_worker_processes"]}
"""

    # Write config to temp file and apply via patronictl
    write_cmd = f"cat > /tmp/pg_config.yaml << 'EOFCONFIG'\n{patch_yaml}EOFCONFIG"
    code, output = run_ssh_command(vm_ip, write_cmd, timeout=30, jump_host=jump_host)
    if code != 0:
        print(f"  Failed to write config file: {output}")
        return False

    # Apply config change via patronictl
    edit_cmd = "patronictl -c /etc/patroni/patroni.yml edit-config --apply /tmp/pg_config.yaml --force"
    code, output = run_ssh_command(vm_ip, edit_cmd, timeout=60, jump_host=jump_host)
    if code != 0:
        print(f"  Failed to update Patroni config: {output}")
        return False

    # Restart cluster to apply pending changes
    restart_cmd = (
        "patronictl -c /etc/patroni/patroni.yml restart postgres-cluster --force"
    )
    code, output = run_ssh_command(vm_ip, restart_cmd, timeout=120, jump_host=jump_host)
    if code != 0:
        print(f"  Warning: Patroni restart returned non-zero: {output}")

    # Wait for cluster to be healthy
    time.sleep(10)
    check_cmd = "patronictl -c /etc/patroni/patroni.yml list"
    code, output = run_ssh_command(vm_ip, check_cmd, timeout=30, jump_host=jump_host)
    if "Leader" in output:
        print("  Patroni cluster reconfigured successfully")
        return True

    print(f"  Warning: Cluster state after restart: {output}")
    return True  # Continue anyway


def ensure_infra(
    cloud_config: CloudConfig, infra_config: dict | None = None
) -> tuple[str, str]:
    """Ensure Postgres and Benchmark VMs exist. Returns (benchmark_ip, postgres_ip)."""
    print(f"\nChecking infrastructure for {cloud_config.name}...")

    tf = get_terraform(cloud_config.terraform_dir)
    mode = infra_config.get("mode", "single") if infra_config else "single"

    postgres_ip = get_tf_output(tf, "postgres_vm_ip")
    benchmark_ip = get_tf_output(tf, "benchmark_vm_ip")

    if postgres_ip and benchmark_ip:
        print(f"  Found Postgres VM: {postgres_ip}")
        print(f"  Found Benchmark VM: {benchmark_ip}")
        try:
            # Use benchmark VM as jump host to reach internal postgres IP
            code, _ = run_ssh_command(
                postgres_ip, "pg_isready", timeout=10, jump_host=benchmark_ip
            )
            if code == 0:
                return benchmark_ip, postgres_ip
        except Exception:
            pass

    print("  Creating infrastructure...")
    tf_start = time.time()
    tf_vars = {
        "postgres_enabled": True,
        "postgres_mode": mode,
        "redis_enabled": False,
        "minio_enabled": False,
    }

    if infra_config:
        tf_vars.update(
            {
                "postgres_cpu": infra_config.get("cpu", 4),
                "postgres_ram_gb": infra_config.get("ram_gb", 16),
                "postgres_disk_type": infra_config.get("disk_type", "nvme"),
                "postgres_disk_size_gb": infra_config.get("disk_size_gb", 100),
            }
        )

    ret_code, stdout, stderr = tf.apply(skip_plan=True, var=tf_vars)
    tf_elapsed = int(time.time() - tf_start)

    if ret_code != 0:
        raise RuntimeError(f"Failed to create infrastructure: {stderr}")

    print(f"  Infrastructure created in {tf_elapsed}s")

    postgres_ip = get_tf_output(tf, "postgres_vm_ip")
    benchmark_ip = get_tf_output(tf, "benchmark_vm_ip")

    if not postgres_ip:
        raise RuntimeError("Postgres VM created but no IP returned")
    if not benchmark_ip:
        raise RuntimeError("Benchmark VM created but no IP returned")

    print(f"  Postgres VM: {postgres_ip}")
    print(f"  Benchmark VM: {benchmark_ip}")

    # Wait for benchmark VM first (it has public IP)
    wait_for_vm_ready(benchmark_ip)
    # Wait for postgres VM via jump host (internal IP only)
    wait_for_vm_ready(postgres_ip, jump_host=benchmark_ip)

    # Wait for Postgres to be ready
    if mode == "cluster":
        wait_for_patroni_ready(postgres_ip, jump_host=benchmark_ip)
    else:
        wait_for_postgres_ready(postgres_ip, jump_host=benchmark_ip)

    return benchmark_ip, postgres_ip


def wait_for_patroni_ready(
    vm_ip: str, timeout: int = 300, jump_host: str | None = None
) -> bool:
    """Wait for Patroni cluster to be ready with a primary."""
    print("  Waiting for Patroni cluster to elect a primary...")

    start = time.time()
    while time.time() - start < timeout:
        try:
            # Check Patroni REST API
            code, output = run_ssh_command(
                vm_ip,
                "curl -s http://localhost:8008/leader 2>/dev/null || curl -s http://localhost:8008/ 2>/dev/null",
                timeout=10,
                jump_host=jump_host,
            )
            if code == 0 and (
                "running" in output.lower() or "leader" in output.lower()
            ):
                # Also verify pg_isready
                code2, _ = run_ssh_command(
                    vm_ip, "pg_isready -h 127.0.0.1", timeout=10, jump_host=jump_host
                )
                if code2 == 0:
                    print(f"  Patroni cluster ready! ({time.time() - start:.0f}s)")
                    return True
        except Exception:
            pass
        time.sleep(10)

    print(f"  Warning: Patroni cluster not ready after {timeout}s")
    return False


def wait_for_postgres_ready(
    vm_ip: str, timeout: int = 180, jump_host: str | None = None
) -> bool:
    """Wait for Postgres to be ready."""
    print("  Waiting for Postgres to be ready...")

    start = time.time()
    while time.time() - start < timeout:
        try:
            code, output = run_ssh_command(
                vm_ip, "pg_isready", timeout=10, jump_host=jump_host
            )
            if code == 0:
                print(f"  Postgres is ready! ({time.time() - start:.0f}s)")
                return True
        except Exception:
            pass
        time.sleep(5)

    print(f"  Warning: Postgres not ready after {timeout}s")
    return False


def initialize_pgbench(
    postgres_ip: str, scale: int = 100, jump_host: str | None = None
) -> bool:
    """Initialize pgbench database on Postgres VM."""
    print(f"  Initializing pgbench (scale={scale}) on Postgres VM...")

    init_cmd = f"sudo -u postgres pgbench -i -s {scale} postgres"
    code, output = run_ssh_command(
        postgres_ip, init_cmd, timeout=300, jump_host=jump_host
    )
    if code != 0:
        print(f"  Warning: pgbench init may have failed: {output[:500]}")
        return False

    print("  pgbench initialized")
    return True


def run_pgbench(
    benchmark_ip: str,
    postgres_ip: str,
    clients: int = 16,
    threads: int = 4,
    duration: int = 60,
) -> BenchmarkResult:
    """Run pgbench from benchmark VM against Postgres VM."""
    print(
        f"  Running pgbench (clients={clients}, duration={duration}s) from benchmark VM..."
    )

    # Connect to postgres VM via its IP
    bench_cmd = (
        f"PGPASSWORD='' pgbench "
        f"-h {postgres_ip} "
        f"-U postgres "
        f"-c {clients} "
        f"-j {threads} "
        f"-T {duration} "
        f"--progress=10 "
        f"postgres 2>&1"
    )

    start_time = time.time()
    try:
        code, output = run_ssh_command(benchmark_ip, bench_cmd, timeout=duration + 60)
    except Exception as e:
        return BenchmarkResult(error=str(e))

    elapsed = time.time() - start_time

    if code != 0:
        return BenchmarkResult(error=output[:500])

    return parse_pgbench_output(output, elapsed)


def parse_pgbench_output(output: str, duration: float) -> BenchmarkResult:
    """Parse pgbench output."""
    result = BenchmarkResult(duration_s=duration)

    # Parse TPS: tps = 1234.567890 (without initial connection time)
    tps_match = re.search(r"tps = ([\d.]+) \(without initial connection time\)", output)
    if tps_match:
        result.tps = float(tps_match.group(1))

    # Parse latency: latency average = 1.234 ms
    lat_avg_match = re.search(r"latency average = ([\d.]+) ms", output)
    if lat_avg_match:
        result.latency_avg_ms = float(lat_avg_match.group(1))

    # Parse stddev: latency stddev = 0.567 ms
    lat_std_match = re.search(r"latency stddev = ([\d.]+) ms", output)
    if lat_std_match:
        result.latency_stddev_ms = float(lat_std_match.group(1))

    # Parse transactions
    txn_match = re.search(r"number of transactions actually processed: (\d+)", output)
    if txn_match:
        result.transactions = int(txn_match.group(1))

    if result.tps == 0:
        print(f"  Warning: Could not parse pgbench output. Sample: {output[:500]}...")

    return result


def calculate_cost(infra_config: dict, cloud: str) -> float:
    """Estimate monthly cost for the configuration."""
    return calculate_vm_cost(
        cloud=cloud,
        cpu=infra_config.get("cpu", 4),
        ram_gb=infra_config.get("ram_gb", 16),
        disks=[
            DiskConfig(
                size_gb=infra_config.get("disk_size_gb", 100),
                disk_type=infra_config.get("disk_type", "fast"),
            )
        ],
    )


def save_result(
    result: BenchmarkResult,
    infra_config: dict,
    pg_config: dict,
    trial_number: int,
    cloud: str,
    mode: str,
    cloud_config: CloudConfig,
) -> None:
    """Save benchmark result to JSON file."""
    results = load_results(results_file())

    timings_dict = None
    if result.timings:
        timings_dict = {
            "terraform_s": result.timings.terraform_s,
            "vm_ready_s": result.timings.vm_ready_s,
            "pg_ready_s": result.timings.pg_ready_s,
            "pgbench_init_s": result.timings.pgbench_init_s,
            "benchmark_s": result.timings.benchmark_s,
            "trial_total_s": result.timings.trial_total_s,
        }

    results.append(
        {
            "trial": trial_number,
            "timestamp": datetime.now().isoformat(),
            "cloud": cloud,
            "mode": mode,
            "infra_config": infra_config,
            "pg_config": pg_config,
            "tps": result.tps,
            "latency_avg_ms": result.latency_avg_ms,
            "latency_stddev_ms": result.latency_stddev_ms,
            "transactions": result.transactions,
            "duration_s": result.duration_s,
            "error": result.error,
            "timings": timings_dict,
        }
    )

    save_results(results, results_file())

    # Auto-export markdown after each trial
    export_results_md(cloud)


def get_metric_value(result: dict, metric: str) -> float:
    """Extract the optimization metric value from a result."""
    if metric == "latency_avg_ms":
        # For latency, we want to minimize, so return negative
        return -result.get("latency_avg_ms", float("inf"))
    return result.get(metric, 0)


def infra_summary(c: dict) -> str:
    """Format infra config as compact string."""
    return f"{c.get('cpu', 0)}cpu/{c.get('ram_gb', 0)}gb/{c.get('disk_type', '?')}"


def pg_summary(c: dict) -> str:
    """Format pg config as compact string."""
    return f"sb={c.get('shared_buffers_pct', 0)}% wm={c.get('work_mem_mb', 0)}mb mc={c.get('max_connections', 0)}"


def format_results(cloud: str) -> dict | None:
    """Format benchmark results for display."""
    results = load_results(results_file())
    if not results:
        return None

    # Filter by cloud
    results = [r for r in results if r.get("cloud", "") == cloud]
    if not results:
        return None

    results_sorted = sorted(results, key=lambda x: x.get("tps", 0), reverse=True)

    rows = []
    for r in results_sorted:
        infra = r.get("infra_config", {})
        pg = r.get("pg_config", {})
        cloud_name = r.get("cloud", cloud)
        # Calculate cost on-the-fly from infra config
        cost = calculate_cost(infra, cloud_name)
        tps = r.get("tps", 0)
        eff = tps / cost if cost > 0 else 0
        rows.append(
            {
                "mode": r.get("mode", "?"),
                "cpu": infra.get("cpu", 0),
                "ram": infra.get("ram_gb", 0),
                "disk": infra.get("disk_type", "?"),
                "sb_pct": pg.get("shared_buffers_pct", 0),
                "wm_mb": pg.get("work_mem_mb", 0),
                "mc": pg.get("max_connections", 0),
                "tps": tps,
                "lat": r.get("latency_avg_ms", 0),
                "cost": cost,
                "eff": eff,
                "_result": r,  # Keep reference for best calculation
            }
        )

    # Best configs - use rows for efficiency (calculated on-the-fly)
    best_tps_row = max(rows, key=lambda x: x.get("tps", 0))
    best_lat_row = min(rows, key=lambda x: x.get("lat", float("inf")))
    best_eff_row = max(rows, key=lambda x: x.get("eff", 0))

    return {
        "cloud": cloud,
        "rows": rows,
        "best": {
            "tps": {
                "value": best_tps_row.get("tps", 0),
                "infra": infra_summary(best_tps_row["_result"].get("infra_config", {})),
                "pg": pg_summary(best_tps_row["_result"].get("pg_config", {})),
            },
            "latency": {
                "value": best_lat_row.get("lat", 0),
                "infra": infra_summary(best_lat_row["_result"].get("infra_config", {})),
                "pg": pg_summary(best_lat_row["_result"].get("pg_config", {})),
            },
            "efficiency": {
                "value": best_eff_row.get("eff", 0),
                "infra": infra_summary(best_eff_row["_result"].get("infra_config", {})),
                "pg": pg_summary(best_eff_row["_result"].get("pg_config", {})),
            },
        },
    }


def show_results(cloud: str) -> None:
    """Display benchmark results."""
    data = format_results(cloud)
    if not data:
        print(f"No results found for {cloud}")
        return

    print(f"\n{'=' * 110}")
    print(f"Postgres Benchmark Results - {cloud.upper()}")
    print(f"{'=' * 110}")

    print(
        f"{'#':>3} {'Mode':<6} {'CPU':>4} {'RAM':>4} {'Disk':<5} {'SB%':>4} {'WM':>5} {'MC':>4} "
        f"{'TPS':>10} {'Lat(ms)':>8} {'$/hr':>6} {'Eff':>8}"
    )
    print("-" * 110)

    for i, r in enumerate(data["rows"], 1):
        print(
            f"{i:>3} {r['mode']:<6} {r['cpu']:>4} {r['ram']:>4} {r['disk']:<5} {r['sb_pct']:>4} {r['wm_mb']:>5} {r['mc']:>4} "
            f"{r['tps']:>10.1f} {r['lat']:>8.2f} {r['cost']:>6.2f} {r['eff']:>8.0f}"
        )

    print("-" * 110)
    print(f"Total: {len(data['rows'])} results")

    best = data["best"]
    print(
        f"\nBest by TPS:        {best['tps']['value']:>10.1f} {'TPS':<8} [{best['tps']['infra']}] [{best['tps']['pg']}]"
    )
    print(
        f"Best by latency:    {best['latency']['value']:>10.2f} {'ms':<8} [{best['latency']['infra']}] [{best['latency']['pg']}]"
    )
    print(
        f"Best by efficiency: {best['efficiency']['value']:>10.0f} {'TPS/$/hr':<8} [{best['efficiency']['infra']}] [{best['efficiency']['pg']}]"
    )


def export_results_md(cloud: str, output_path: Path | None = None) -> None:
    """Export benchmark results to markdown."""
    data = format_results(cloud)
    if not data:
        print(f"No results found for {cloud}")
        return

    if output_path is None:
        output_path = RESULTS_DIR / f"RESULTS_{cloud.upper()}.md"

    lines = [
        f"# Postgres Benchmark Results - {cloud.upper()}",
        "",
        f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
        "",
        "## Results",
        "",
        "| # | Mode | CPU | RAM | Disk | SB% | WM | MC | TPS | Lat(ms) | $/hr | Efficiency |",
        "|--:|------|----:|----:|------|----:|---:|---:|----:|--------:|-----:|-----------:|",
    ]

    for i, r in enumerate(data["rows"], 1):
        lines.append(
            f"| {i} | {r['mode']} | {r['cpu']} | {r['ram']} | {r['disk']} | {r['sb_pct']} | {r['wm_mb']} | {r['mc']} "
            f"| {r['tps']:.1f} | {r['lat']:.2f} | {r['cost']:.2f} | {r['eff']:.0f} |"
        )

    best = data["best"]
    lines.extend(
        [
            "",
            "## Best Configurations",
            "",
            f"- **Best by TPS:** {best['tps']['value']:.1f} TPS — `{best['tps']['infra']}` `{best['tps']['pg']}`",
            f"- **Best by latency:** {best['latency']['value']:.2f}ms — `{best['latency']['infra']}` `{best['latency']['pg']}`",
            f"- **Best by efficiency:** {best['efficiency']['value']:.0f} TPS/$/hr — `{best['efficiency']['infra']}` `{best['efficiency']['pg']}`",
            "",
        ]
    )

    output_path.write_text("\n".join(lines))
    print(f"Results exported to {output_path}")


def objective_infra(
    trial: optuna.Trial,
    cloud: str,
    cloud_config: CloudConfig,
    metric: str = "tps",
) -> float:
    """Objective function for infrastructure optimization."""
    space = get_infra_search_space(cloud)

    # Select CPU first, then filter valid RAM options for that CPU
    cpu = trial.suggest_categorical("cpu", space["cpu"])
    valid_ram = filter_valid_ram(cloud, cpu, space["ram_gb"])

    infra_config = {
        "mode": trial.suggest_categorical("mode", space["mode"]),
        "cpu": cpu,
        "ram_gb": trial.suggest_categorical(f"ram_gb_cpu{cpu}", valid_ram),
        "disk_type": trial.suggest_categorical("disk_type", space["disk_type"]),
        "disk_size_gb": trial.suggest_categorical(
            "disk_size_gb", space["disk_size_gb"]
        ),
    }

    # Use reasonable default Postgres config
    ram_gb = infra_config["ram_gb"]
    pg_config = {
        "shared_buffers_pct": 25,
        "effective_cache_size_pct": 75,
        "work_mem_mb": 64,
        "maintenance_work_mem_mb": 256,
        "max_connections": 100,
        "random_page_cost": 1.1,
        "effective_io_concurrency": 200,
        "wal_buffers_mb": 64,
        "max_wal_size_gb": 2,
        "checkpoint_completion_target": 0.9,
        "max_worker_processes": min(infra_config["cpu"], 8),
        "max_parallel_workers_per_gather": min(infra_config["cpu"] // 2, 4),
    }

    print(f"\n{'=' * 60}")
    print(f"Trial {trial.number} [infra]: {infra_config}")
    print(f"{'=' * 60}")
    trial_start = time.time()
    timings = TrialTimings()

    # Check cache
    cached = find_cached_result(infra_config, pg_config, cloud)
    if cached:
        cached_value = get_metric_value(cached, metric)
        print(f"  Using cached result: {cached_value:.2f} ({metric})")
        return cached_value

    # Destroy and recreate VM with new specs
    print("  Destroying previous VM...")
    destroy_all(cloud_config.terraform_dir, cloud_config.name)
    time.sleep(5)

    # Create VMs
    try:
        infra_start = time.time()
        benchmark_ip, postgres_ip = ensure_infra(cloud_config, infra_config)
        timings.terraform_s = time.time() - infra_start
    except Exception as e:
        print(f"  Failed to create infrastructure: {e}")
        raise optuna.TrialPruned("Infrastructure creation failed")

    # Configure Postgres
    mode = infra_config.get("mode", "single")
    if not reconfigure_postgres(
        postgres_ip, pg_config, ram_gb, mode, jump_host=benchmark_ip
    ):
        raise optuna.TrialPruned("Postgres config failed")

    # Initialize pgbench (scale based on RAM)
    init_start = time.time()
    scale = max(50, ram_gb * 10)
    if not initialize_pgbench(postgres_ip, scale=scale, jump_host=benchmark_ip):
        raise optuna.TrialPruned("pgbench init failed")
    timings.pgbench_init_s = time.time() - init_start

    # Run benchmark
    bench_start = time.time()
    result = run_pgbench(
        benchmark_ip, postgres_ip, clients=infra_config["cpu"] * 4, duration=60
    )
    timings.benchmark_s = time.time() - bench_start

    if result.error:
        print(f"  Benchmark failed: {result.error}")
        raise optuna.TrialPruned(result.error)

    timings.trial_total_s = time.time() - trial_start
    result.timings = timings

    print(f"  Result: {result.tps:.1f} TPS, {result.latency_avg_ms:.2f}ms latency")
    print(
        f"  Timings: infra={timings.terraform_s:.0f}s, init={timings.pgbench_init_s:.0f}s, "
        f"bench={timings.benchmark_s:.0f}s, total={timings.trial_total_s:.0f}s"
    )

    # Save result
    save_result(
        result, infra_config, pg_config, trial.number, cloud, "infra", cloud_config
    )

    return get_metric_value(
        {
            "tps": result.tps,
            "latency_avg_ms": result.latency_avg_ms,
            "cost_efficiency": result.tps / calculate_cost(infra_config, cloud),
        },
        metric,
    )


def objective_config(
    trial: optuna.Trial,
    cloud: str,
    cloud_config: CloudConfig,
    benchmark_ip: str,
    postgres_ip: str,
    infra_config: dict,
    metric: str = "tps",
) -> float:
    """Objective function for Postgres config optimization (fixed host)."""
    ram_gb = infra_config["ram_gb"]
    space = get_config_search_space(ram_gb)

    pg_config = {
        "shared_buffers_pct": trial.suggest_categorical(
            "shared_buffers_pct", space["shared_buffers_pct"]
        ),
        "effective_cache_size_pct": trial.suggest_categorical(
            "effective_cache_size_pct", space["effective_cache_size_pct"]
        ),
        "work_mem_mb": trial.suggest_categorical("work_mem_mb", space["work_mem_mb"]),
        "maintenance_work_mem_mb": trial.suggest_categorical(
            "maintenance_work_mem_mb", space["maintenance_work_mem_mb"]
        ),
        "max_connections": trial.suggest_categorical(
            "max_connections", space["max_connections"]
        ),
        "random_page_cost": trial.suggest_categorical(
            "random_page_cost", space["random_page_cost"]
        ),
        "effective_io_concurrency": trial.suggest_categorical(
            "effective_io_concurrency", space["effective_io_concurrency"]
        ),
        "wal_buffers_mb": trial.suggest_categorical(
            "wal_buffers_mb", space["wal_buffers_mb"]
        ),
        "max_wal_size_gb": trial.suggest_categorical(
            "max_wal_size_gb", space["max_wal_size_gb"]
        ),
        "checkpoint_completion_target": trial.suggest_categorical(
            "checkpoint_completion_target", space["checkpoint_completion_target"]
        ),
        "max_worker_processes": trial.suggest_categorical(
            "max_worker_processes", space["max_worker_processes"]
        ),
        "max_parallel_workers_per_gather": trial.suggest_categorical(
            "max_parallel_workers_per_gather", space["max_parallel_workers_per_gather"]
        ),
    }

    print(f"\n{'=' * 60}")
    print(f"Trial {trial.number} [config]: {pg_summary(pg_config)}")
    print(f"{'=' * 60}")
    trial_start = time.time()
    timings = TrialTimings()

    # Check cache
    cached = find_cached_result(infra_config, pg_config, cloud)
    if cached:
        cached_value = get_metric_value(cached, metric)
        print(f"  Using cached result: {cached_value:.2f} ({metric})")
        return cached_value

    # Reconfigure Postgres (no VM recreation)
    mode = infra_config.get("mode", "single")
    if not reconfigure_postgres(
        postgres_ip, pg_config, ram_gb, mode, jump_host=benchmark_ip
    ):
        raise optuna.TrialPruned("Postgres config failed")

    # Run benchmark
    bench_start = time.time()
    result = run_pgbench(
        benchmark_ip, postgres_ip, clients=infra_config["cpu"] * 4, duration=60
    )
    timings.benchmark_s = time.time() - bench_start

    if result.error:
        print(f"  Benchmark failed: {result.error}")
        raise optuna.TrialPruned(result.error)

    timings.trial_total_s = time.time() - trial_start
    result.timings = timings

    print(f"  Result: {result.tps:.1f} TPS, {result.latency_avg_ms:.2f}ms latency")
    print(
        f"  Timings: bench={timings.benchmark_s:.0f}s, total={timings.trial_total_s:.0f}s"
    )

    # Save result
    save_result(
        result, infra_config, pg_config, trial.number, cloud, "config", cloud_config
    )

    return get_metric_value(
        {
            "tps": result.tps,
            "latency_avg_ms": result.latency_avg_ms,
            "cost_efficiency": result.tps / calculate_cost(infra_config, cloud),
        },
        metric,
    )


def main():
    parser = argparse.ArgumentParser(
        description="Postgres configuration optimizer",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Tune VM specs
  uv run python postgres-optimizer/optimizer.py --cloud timeweb --mode infra --trials 10

  # Tune postgresql.conf on 8cpu/32gb host
  uv run python postgres-optimizer/optimizer.py --cloud timeweb --mode config --cpu 8 --ram 32 --trials 50

  # Full optimization
  uv run python postgres-optimizer/optimizer.py --cloud timeweb --mode full --trials 20
""",
    )

    parser.add_argument("--cloud", required=True, choices=["selectel", "timeweb"])
    parser.add_argument("--mode", choices=["infra", "config", "full"], default="config")
    parser.add_argument("--trials", type=int, default=20)
    parser.add_argument("--metric", choices=list(METRICS.keys()), default="tps")

    # Fixed host settings for config mode
    parser.add_argument("--cpu", type=int, default=4, help="CPU cores for config mode")
    parser.add_argument("--ram", type=int, default=16, help="RAM GB for config mode")

    parser.add_argument(
        "--no-destroy", action="store_true", help="Don't destroy infra at end"
    )
    parser.add_argument(
        "--show-results", action="store_true", help="Show results and exit"
    )
    parser.add_argument(
        "--export-md", action="store_true", help="Export to markdown and exit"
    )

    args = parser.parse_args()

    cloud_config = get_cloud_config(args.cloud)
    mode = Mode(args.mode)

    # Handle display modes
    if args.show_results:
        show_results(args.cloud)
        return

    if args.export_md:
        export_results_md(args.cloud)
        return

    print(f"\nPostgres Optimizer - {args.cloud.upper()} [{mode.value}]")
    print(f"Metric: {args.metric} - {METRICS[args.metric]}")
    print(f"Trials: {args.trials}")

    study: optuna.Study | None = None

    try:
        if mode == Mode.INFRA:
            # Infrastructure optimization
            study = optuna.create_study(
                study_name=f"postgres-{args.cloud}-infra-{args.metric}",
                storage=f"sqlite:///{STUDY_DB}",
                load_if_exists=True,
                direction="maximize" if args.metric != "latency_avg_ms" else "minimize",
                sampler=TPESampler(seed=42),
            )

            study.optimize(
                lambda trial: objective_infra(
                    trial, args.cloud, cloud_config, args.metric
                ),
                n_trials=args.trials,
                catch=(optuna.TrialPruned,),
            )

        elif mode == Mode.CONFIG:
            # Config optimization on fixed host
            infra_config = {
                "cpu": args.cpu,
                "ram_gb": args.ram,
                "disk_type": "nvme" if args.cloud == "timeweb" else "fast",
                "disk_size_gb": 100,
            }

            print(f"Fixed host: {infra_summary(infra_config)}")

            # Ensure VMs exist
            benchmark_ip, postgres_ip = ensure_infra(cloud_config, infra_config)
            print(f"\nPostgres VM IP: {postgres_ip}")
            print(f"Benchmark VM IP: {benchmark_ip}")

            # Initialize pgbench once
            scale = max(50, args.ram * 10)
            initialize_pgbench(postgres_ip, scale=scale, jump_host=benchmark_ip)

            study = optuna.create_study(
                study_name=f"postgres-{args.cloud}-config-{args.metric}",
                storage=f"sqlite:///{STUDY_DB}",
                load_if_exists=True,
                direction="maximize" if args.metric != "latency_avg_ms" else "minimize",
                sampler=TPESampler(seed=42),
            )

            study.optimize(
                lambda trial: objective_config(
                    trial,
                    args.cloud,
                    cloud_config,
                    benchmark_ip,
                    postgres_ip,
                    infra_config,
                    args.metric,
                ),
                n_trials=args.trials,
                catch=(optuna.TrialPruned,),
            )

        elif mode == Mode.FULL:
            # Full optimization: infra first, then config
            print("\n=== Phase 1: Infrastructure optimization ===")

            study_infra = optuna.create_study(
                study_name=f"postgres-{args.cloud}-full-infra-{args.metric}",
                storage=f"sqlite:///{STUDY_DB}",
                load_if_exists=True,
                direction="maximize",
                sampler=TPESampler(seed=42),
            )

            infra_trials = max(5, args.trials // 3)
            study_infra.optimize(
                lambda trial: objective_infra(
                    trial, args.cloud, cloud_config, args.metric
                ),
                n_trials=infra_trials,
                catch=(optuna.TrialPruned,),
            )

            # Get best infra config
            best_infra = study_infra.best_params
            infra_config = {
                "cpu": best_infra["cpu"],
                "ram_gb": best_infra["ram_gb"],
                "disk_type": best_infra["disk_type"],
                "disk_size_gb": best_infra["disk_size_gb"],
            }

            print("\n=== Phase 2: Config optimization on best host ===")
            print(f"Best host: {infra_summary(infra_config)}")

            # Create VMs with best infra
            destroy_all(cloud_config.terraform_dir, cloud_config.name)
            benchmark_ip, postgres_ip = ensure_infra(cloud_config, infra_config)

            scale = max(50, infra_config["ram_gb"] * 10)
            initialize_pgbench(postgres_ip, scale=scale, jump_host=benchmark_ip)

            study_config = optuna.create_study(
                study_name=f"postgres-{args.cloud}-full-config-{args.metric}",
                storage=f"sqlite:///{STUDY_DB}",
                load_if_exists=True,
                direction="maximize" if args.metric != "latency_avg_ms" else "minimize",
                sampler=TPESampler(seed=42),
            )

            config_trials = args.trials - infra_trials
            study_config.optimize(
                lambda trial: objective_config(
                    trial,
                    args.cloud,
                    cloud_config,
                    benchmark_ip,
                    postgres_ip,
                    infra_config,
                    args.metric,
                ),
                n_trials=config_trials,
                catch=(optuna.TrialPruned,),
            )

            study = study_config  # For final output

        # Print results
        print(f"\n{'=' * 60}")
        print(f"OPTIMIZATION COMPLETE ({args.cloud.upper()} [{mode.value}])")
        print(f"{'=' * 60}")

        if study is not None:
            try:
                best = study.best_trial
                print(f"Best trial: {best.number}")
                print(f"Best params: {best.params}")
                print(f"Best {args.metric}: {best.value:.2f}")
            except ValueError:
                print("No successful trials completed")
        else:
            print("No study was created")

        # Auto-export results
        export_results_md(args.cloud)
        print(f"\nResults exported to RESULTS_{args.cloud.upper()}.md")

    finally:
        if not args.no_destroy:
            destroy_all(cloud_config.terraform_dir, cloud_config.name)
        else:
            print("\n--no-destroy specified, keeping infrastructure.")


if __name__ == "__main__":
    main()
